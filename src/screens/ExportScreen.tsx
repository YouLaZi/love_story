import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, Alert } from 'react-native';
import {
  Surface,
  Text,
  Card,
  Button,
  Chip,
  Switch,
  TextInput,
  SegmentedButtons,
  ProgressBar,
  Portal,
  Dialog,
} from 'react-native-paper';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { useDatabase } from '../contexts/DatabaseContext';
import { ExportOptions } from '../types';
import { format, subDays, subMonths, subYears } from 'date-fns';
import { zhCN } from 'date-fns/locale';
import * as Sharing from 'expo-sharing';
import * as Print from 'expo-print';
import * as FileSystem from 'expo-file-system';
import * as Animatable from 'react-native-animatable';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

const ExportScreen: React.FC = () => {
  const { theme } = useTheme();
  const { user } = useAuth();
  const { databaseService } = useDatabase();
  
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    format: 'pdf',
    includeAttachments: true,
    includePrivateEntries: false,
    template: 'detailed',
  });
  
  const [dateRangeType, setDateRangeType] = useState<'all' | 'custom' | 'recent'>('all');
  const [customStartDate, setCustomStartDate] = useState('');
  const [customEndDate, setCustomEndDate] = useState('');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [availableTags, setAvailableTags] = useState<string[]>([]);
  const [isExporting, setIsExporting] = useState(false);
  const [exportProgress, setExportProgress] = useState(0);
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [encryptionPassword, setEncryptionPassword] = useState('');

  const formatOptions = [
    { value: 'pdf', label: 'PDF' },
    { value: 'html', label: 'HTML' },
    { value: 'json', label: 'JSON' },
    { value: 'images', label: 'ÂõæÁâá' },
  ];

  const templateOptions = [
    { value: 'simple', label: 'ÁÆÄÊ¥Å' },
    { value: 'detailed', label: 'ËØ¶ÁªÜ' },
    { value: 'timeline', label: 'Êó∂Èó¥Á∫ø' },
    { value: 'album', label: 'Áõ∏ÂÜå' },
  ];

  const dateRangeOptions = [
    { value: 'all', label: 'ÂÖ®ÈÉ®' },
    { value: 'recent', label: 'ÊúÄËøë' },
    { value: 'custom', label: 'Ëá™ÂÆö‰πâ' },
  ];

  React.useEffect(() => {
    loadTags();
  }, []);

  const loadTags = async () => {
    if (!user) return;
    
    try {
      const tags = await databaseService.getTagsByUserId(user.id);
      setAvailableTags(tags.map(tag => tag.name));
    } catch (error) {
      console.error('Failed to load tags:', error);
    }
  };

  const getDateRange = () => {
    const now = new Date();
    
    switch (dateRangeType) {
      case 'recent':
        return {
          start: subMonths(now, 3),
          end: now,
        };
      case 'custom':
        return {
          start: customStartDate ? new Date(customStartDate) : subYears(now, 1),
          end: customEndDate ? new Date(customEndDate) : now,
        };
      case 'all':
      default:
        return undefined;
    }
  };

  const startExport = async () => {
    if (!user) return;

    // Â¶ÇÊûúÂåÖÂê´ÁßÅÂØÜÊù°ÁõÆÔºåÈúÄË¶ÅËÆæÁΩÆÂä†ÂØÜÂØÜÁ†Å
    if (exportOptions.includePrivateEntries && exportOptions.format !== 'json') {
      setShowPasswordDialog(true);
      return;
    }

    await performExport();
  };

  const performExport = async () => {
    try {
      setIsExporting(true);
      setExportProgress(0);

      // Ëé∑ÂèñË¶ÅÂØºÂá∫ÁöÑÊï∞ÊçÆ
      setExportProgress(0.2);
      const entries = await databaseService.getDiaryEntries(user!.id);
      
      // ËøáÊª§Êï∞ÊçÆ
      setExportProgress(0.4);
      const filteredEntries = filterEntries(entries);
      
      if (filteredEntries.length === 0) {
        Alert.alert('ÊèêÁ§∫', 'Ê≤°ÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑÊó•ËÆ∞ÂèØ‰ª•ÂØºÂá∫', [{ text: 'Á°ÆÂÆö' }]);
        return;
      }

      // ÁîüÊàêÂØºÂá∫Êñá‰ª∂
      setExportProgress(0.6);
      const fileUri = await generateExportFile(filteredEntries);
      
      setExportProgress(0.9);
      
      // ÂàÜ‰∫´Êñá‰ª∂
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(fileUri);
      } else {
        Alert.alert('ÂàÜ‰∫´‰∏çÂèØÁî®', 'Êó†Ê≥ïÂú®Ê≠§ËÆæÂ§á‰∏äÂàÜ‰∫´Êñá‰ª∂', [{ text: 'Á°ÆÂÆö' }]);
      }
      
      setExportProgress(1);
      
      Alert.alert(
        'ÂØºÂá∫ÊàêÂäü',
        `ÊàêÂäüÂØºÂá∫ ${filteredEntries.length} ÁØáÊó•ËÆ∞`,
        [{ text: 'Á°ÆÂÆö' }]
      );

    } catch (error) {
      console.error('Export error:', error);
      Alert.alert('ÂØºÂá∫Â§±Ë¥•', 'ÂØºÂá∫ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï', [{ text: 'Á°ÆÂÆö' }]);
    } finally {
      setIsExporting(false);
      setShowPasswordDialog(false);
      setEncryptionPassword('');
    }
  };

  const filterEntries = (entries: any[]) => {
    let filtered = entries;

    // ÊåâÊó•ÊúüËåÉÂõ¥ËøáÊª§
    const dateRange = getDateRange();
    if (dateRange) {
      filtered = filtered.filter(entry => {
        const entryDate = new Date(entry.createdAt);
        return entryDate >= dateRange.start && entryDate <= dateRange.end;
      });
    }

    // ÊåâÊ†áÁ≠æËøáÊª§
    if (selectedTags.length > 0) {
      filtered = filtered.filter(entry =>
        entry.tags.some((tag: string) => selectedTags.includes(tag))
      );
    }

    // ÊåâÈöêÁßÅËÆæÁΩÆËøáÊª§
    if (!exportOptions.includePrivateEntries) {
      filtered = filtered.filter(entry => !entry.isPrivate);
    }

    return filtered;
  };

  const generateExportFile = async (entries: any[]): Promise<string> => {
    const fileName = `diary_export_${format(new Date(), 'yyyyMMdd_HHmmss')}`;
    
    switch (exportOptions.format) {
      case 'pdf':
        return await generatePDF(entries, fileName);
      case 'html':
        return await generateHTML(entries, fileName);
      case 'json':
        return await generateJSON(entries, fileName);
      case 'images':
        return await generateImages(entries, fileName);
      default:
        throw new Error('Unsupported export format');
    }
  };

  const generatePDF = async (entries: any[], fileName: string): Promise<string> => {
    const html = generateHTMLContent(entries);
    
    const { uri } = await Print.printToFileAsync({
      html,
      base64: false,
    });
    
    const newUri = `${FileSystem.documentDirectory}${fileName}.pdf`;
    await FileSystem.moveAsync({
      from: uri,
      to: newUri,
    });
    
    return newUri;
  };

  const generateHTML = async (entries: any[], fileName: string): Promise<string> => {
    const html = generateHTMLContent(entries);
    const uri = `${FileSystem.documentDirectory}${fileName}.html`;
    
    await FileSystem.writeAsStringAsync(uri, html);
    return uri;
  };

  const generateJSON = async (entries: any[], fileName: string): Promise<string> => {
    const exportData = {
      exportDate: new Date().toISOString(),
      user: {
        username: user?.username,
        email: user?.email,
      },
      entries,
      options: exportOptions,
    };
    
    const jsonString = JSON.stringify(exportData, null, 2);
    const uri = `${FileSystem.documentDirectory}${fileName}.json`;
    
    await FileSystem.writeAsStringAsync(uri, jsonString);
    return uri;
  };

  const generateImages = async (entries: any[], fileName: string): Promise<string> => {
    // ‰∏∫ÊØèÁØáÊó•ËÆ∞ÁîüÊàêÂõæÁâá
    // ËøôÈáåÈúÄË¶ÅÂÆûÁé∞Â∞ÜÊó•ËÆ∞ÂÜÖÂÆπËΩ¨Êç¢‰∏∫ÂõæÁâáÁöÑÈÄªËæë
    // ÂèØ‰ª•‰ΩøÁî® react-native-view-shot ÊàñÁ±ª‰ººÂ∫ì
    throw new Error('Images export not implemented yet');
  };

  const generateHTMLContent = (entries: any[]): string => {
    const { template } = exportOptions;
    
    const entriesHTML = entries.map(entry => {
      const date = format(new Date(entry.createdAt), 'yyyyÂπ¥MMÊúàddÊó• EEEE HH:mm', { locale: zhCN });
      const tags = entry.tags.map((tag: string) => `<span class="tag">${tag}</span>`).join('');
      
      return `
        <div class="entry">
          <div class="entry-header">
            <h2 class="entry-title">${entry.title}</h2>
            <div class="entry-meta">
              <span class="entry-date">${date}</span>
              <span class="entry-mood">${entry.mood}</span>
            </div>
          </div>
          <div class="entry-content">
            <p>${entry.content.replace(/\n/g, '<br>')}</p>
          </div>
          ${tags ? `<div class="entry-tags">${tags}</div>` : ''}
          ${entry.location ? `<div class="entry-location">üìç ${entry.location}</div>` : ''}
          ${entry.weather ? `<div class="entry-weather">üå§Ô∏è ${entry.weather}</div>` : ''}
        </div>
      `;
    }).join('');

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>ÊàëÁöÑÊó•ËÆ∞ - Story4Love</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 2px solid #ff6b9d;
            padding-bottom: 20px;
          }
          .entry {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
          }
          .entry-header {
            margin-bottom: 15px;
          }
          .entry-title {
            color: #ff6b9d;
            margin: 0 0 10px 0;
          }
          .entry-meta {
            color: #666;
            font-size: 14px;
          }
          .entry-content {
            margin: 15px 0;
          }
          .entry-tags {
            margin-top: 15px;
          }
          .tag {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-right: 8px;
          }
          .entry-location, .entry-weather {
            font-size: 14px;
            color: #666;
            margin-top: 8px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>ÊàëÁöÑÊÅãÁà±Êó•ËÆ∞</h1>
          <p>ÂØºÂá∫Êó∂Èó¥: ${format(new Date(), 'yyyyÂπ¥MMÊúàddÊó• HH:mm', { locale: zhCN })}</p>
          <p>ÂÖ± ${entries.length} ÁØáÊó•ËÆ∞</p>
        </div>
        ${entriesHTML}
        <div style="text-align: center; margin-top: 40px; color: #999; font-size: 12px;">
          Áî± Story4Love ÁîüÊàê
        </div>
      </body>
      </html>
    `;
  };

  const toggleTag = (tag: string) => {
    setSelectedTags(prev =>
      prev.includes(tag)
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  return (
    <Surface style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {/* ÂØºÂá∫Ê†ºÂºè */}
        <Animatable.View animation="fadeInDown">
          <Text style={[styles.sectionTitle, { color: theme.colors.onSurface }]}>
            ÂØºÂá∫Ê†ºÂºè
          </Text>
          <SegmentedButtons
            value={exportOptions.format}
            onValueChange={(value) => setExportOptions(prev => ({ ...prev, format: value as any }))}
            buttons={formatOptions}
            style={styles.segmentedButtons}
          />
        </Animatable.View>

        {/* Ê®°ÊùøÈÄâÊã© */}
        {(exportOptions.format === 'pdf' || exportOptions.format === 'html') && (
          <Animatable.View animation="fadeInUp" delay={200}>
            <Text style={[styles.sectionTitle, { color: theme.colors.onSurface }]}>
              Ê®°ÊùøÊ†∑Âºè
            </Text>
            <SegmentedButtons
              value={exportOptions.template}
              onValueChange={(value) => setExportOptions(prev => ({ ...prev, template: value as any }))}
              buttons={templateOptions}
              style={styles.segmentedButtons}
            />
          </Animatable.View>
        )}

        {/* Êó∂Èó¥ËåÉÂõ¥ */}
        <Animatable.View animation="fadeInUp" delay={400}>
          <Text style={[styles.sectionTitle, { color: theme.colors.onSurface }]}>
            Êó∂Èó¥ËåÉÂõ¥
          </Text>
          <SegmentedButtons
            value={dateRangeType}
            onValueChange={(value) => setDateRangeType(value as any)}
            buttons={dateRangeOptions}
            style={styles.segmentedButtons}
          />
          
          {dateRangeType === 'custom' && (
            <View style={styles.customDateRange}>
              <TextInput
                label="ÂºÄÂßãÊó•Êúü"
                value={customStartDate}
                onChangeText={setCustomStartDate}
                mode="outlined"
                style={styles.dateInput}
                placeholder="YYYY-MM-DD"
              />
              <TextInput
                label="ÁªìÊùüÊó•Êúü"
                value={customEndDate}
                onChangeText={setCustomEndDate}
                mode="outlined"
                style={styles.dateInput}
                placeholder="YYYY-MM-DD"
              />
            </View>
          )}
        </Animatable.View>

        {/* Ê†áÁ≠æÁ≠õÈÄâ */}
        <Animatable.View animation="fadeInUp" delay={600}>
          <Text style={[styles.sectionTitle, { color: theme.colors.onSurface }]}>
            Ê†áÁ≠æÁ≠õÈÄâ
          </Text>
          <Card style={[styles.tagsCard, { backgroundColor: theme.colors.surface }]}>
            <Card.Content>
              <Text style={[styles.tagsHelper, { color: theme.colors.onSurfaceVariant }]}>
                ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑÊ†áÁ≠æÔºà‰∏çÈÄâÊã©ÂàôÂØºÂá∫ÂÖ®ÈÉ®Ôºâ
              </Text>
              <View style={styles.tagsContainer}>
                {availableTags.map(tag => (
                  <Chip
                    key={tag}
                    selected={selectedTags.includes(tag)}
                    onPress={() => toggleTag(tag)}
                    style={styles.tag}
                  >
                    {tag}
                  </Chip>
                ))}
              </View>
            </Card.Content>
          </Card>
        </Animatable.View>

        {/* ÂØºÂá∫ÈÄâÈ°π */}
        <Animatable.View animation="fadeInUp" delay={800}>
          <Text style={[styles.sectionTitle, { color: theme.colors.onSurface }]}>
            ÂØºÂá∫ÈÄâÈ°π
          </Text>
          <Card style={[styles.optionsCard, { backgroundColor: theme.colors.surface }]}>
            <Card.Content>
              <View style={styles.optionRow}>
                <View style={styles.optionInfo}>
                  <Text style={[styles.optionTitle, { color: theme.colors.onSurface }]}>
                    ÂåÖÂê´ÈôÑ‰ª∂
                  </Text>
                  <Text style={[styles.optionDesc, { color: theme.colors.onSurfaceVariant }]}>
                    ÂØºÂá∫ÂõæÁâá„ÄÅÈü≥È¢ëÁ≠âÈôÑ‰ª∂Êñá‰ª∂
                  </Text>
                </View>
                <Switch
                  value={exportOptions.includeAttachments}
                  onValueChange={(value) => setExportOptions(prev => ({ ...prev, includeAttachments: value }))}
                />
              </View>
              
              <View style={styles.optionRow}>
                <View style={styles.optionInfo}>
                  <Text style={[styles.optionTitle, { color: theme.colors.onSurface }]}>
                    ÂåÖÂê´ÁßÅÂØÜÊó•ËÆ∞
                  </Text>
                  <Text style={[styles.optionDesc, { color: theme.colors.onSurfaceVariant }]}>
                    ÂØºÂá∫Ê†áËÆ∞‰∏∫ÁßÅÂØÜÁöÑÊó•ËÆ∞ÂÜÖÂÆπ
                  </Text>
                </View>
                <Switch
                  value={exportOptions.includePrivateEntries}
                  onValueChange={(value) => setExportOptions(prev => ({ ...prev, includePrivateEntries: value }))}
                />
              </View>
            </Card.Content>
          </Card>
        </Animatable.View>

        {/* ÂØºÂá∫ËøõÂ∫¶ */}
        {isExporting && (
          <Animatable.View animation="fadeInUp" style={styles.progressSection}>
            <Card style={[styles.progressCard, { backgroundColor: theme.colors.surface }]}>
              <Card.Content>
                <Text style={[styles.progressTitle, { color: theme.colors.onSurface }]}>
                  Ê≠£Âú®ÂØºÂá∫...
                </Text>
                <ProgressBar
                  progress={exportProgress}
                  color={theme.colors.primary}
                  style={styles.progressBar}
                />
                <Text style={[styles.progressText, { color: theme.colors.onSurfaceVariant }]}>
                  {Math.round(exportProgress * 100)}% ÂÆåÊàê
                </Text>
              </Card.Content>
            </Card>
          </Animatable.View>
        )}

        {/* ÂØºÂá∫ÊåâÈíÆ */}
        <Animatable.View animation="fadeInUp" delay={1000}>
          <Button
            mode="contained"
            onPress={startExport}
            loading={isExporting}
            disabled={isExporting}
            style={styles.exportButton}
            icon="export"
          >
            ÂºÄÂßãÂØºÂá∫
          </Button>
        </Animatable.View>
      </ScrollView>

      {/* Âä†ÂØÜÂØÜÁ†ÅÂØπËØùÊ°Ü */}
      <Portal>
        <Dialog visible={showPasswordDialog} onDismiss={() => setShowPasswordDialog(false)}>
          <Dialog.Title>ËÆæÁΩÆÂä†ÂØÜÂØÜÁ†Å</Dialog.Title>
          <Dialog.Content>
            <Text style={{ marginBottom: 16 }}>
              Áî±‰∫éÂØºÂá∫ÂÜÖÂÆπÂåÖÂê´ÁßÅÂØÜÊó•ËÆ∞ÔºåËØ∑ËÆæÁΩÆ‰∏Ä‰∏™ÂØÜÁ†ÅÊù•‰øùÊä§Êñá‰ª∂ÂÆâÂÖ®Ôºö
            </Text>
            <TextInput
              label="Âä†ÂØÜÂØÜÁ†Å"
              value={encryptionPassword}
              onChangeText={setEncryptionPassword}
              mode="outlined"
              secureTextEntry
              placeholder="Ëá≥Â∞ë6‰ΩçÂ≠óÁ¨¶"
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowPasswordDialog(false)}>
              ÂèñÊ∂à
            </Button>
            <Button
              mode="contained"
              onPress={performExport}
              disabled={encryptionPassword.length < 6}
            >
              Á°ÆÂÆöÂØºÂá∫
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    marginTop: 24,
  },
  segmentedButtons: {
    marginBottom: 16,
  },
  customDateRange: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 16,
  },
  dateInput: {
    flex: 1,
  },
  tagsCard: {
    elevation: 2,
  },
  tagsHelper: {
    fontSize: 12,
    marginBottom: 12,
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  tag: {
    marginBottom: 4,
  },
  optionsCard: {
    elevation: 2,
  },
  optionRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
  },
  optionInfo: {
    flex: 1,
    marginRight: 16,
  },
  optionTitle: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  optionDesc: {
    fontSize: 12,
  },
  progressSection: {
    marginTop: 24,
  },
  progressCard: {
    elevation: 4,
  },
  progressTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
    marginBottom: 8,
  },
  progressText: {
    textAlign: 'center',
  },
  exportButton: {
    marginTop: 32,
    paddingVertical: 8,
  },
});

export default ExportScreen;
